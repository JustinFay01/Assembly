Microsoft (R) Macro Assembler Version 14.35.32216.1	    04/12/23 14:22:56
example.asm						     Page 1 - 1


				;  Week 14 day 1 Exercise: Bubble Sort!
				;
				;  Mike Jipping
				;  April 2019


				.586
				.MODEL FLAT

				INCLUDE io.h            ; header file for input/output
			      C ; IO.H -- header file for I/O macros (listing suppressed)
			      C .NOLIST      ; turn off listing
			      C .LIST        ; begin listing
			      C 

				.STACK 4096

 00000000			.DATA
 00000000 0000000A		array   DWORD   10, 30, 20, 100, 90, 30, 9, 40, 35, 0
	   0000001E
	   00000014
	   00000064
	   0000005A
	   0000001E
	   00000009
	   00000028
	   00000023
	   00000000
 00000028 00000000		temp    DWORD   ?
 0000002C  00000064 [		string  BYTE    100 DUP (?)
	    00
	   ]
 00000090  0000000B [		numstr  BYTE    11 DUP (?), 0
	    00
	   ] 00
 0000009C 55 6E 73 6F 72	prompt1 BYTE    "Unsorted List", 0
	   74 65 64 20 4C
	   69 73 74 00
 000000AA 53 6F 72 74 65	prompt2 BYTE    "Sorted List", 0
	   64 20 4C 69 73
	   74 00
 000000B6 00000000		inlimit DWORD   ?

 000000BA 00000000		n       DWORD   ?
 000000BE 00000000		i       DWORD   0
 000000C2 00000000		j       DWORD   0
 000000C6 00000000		tmp     DWORD   0
 000000CA  0000000A [		testStr DWORD   10 DUP (?), 0
	    00000000
	   ] 00000000
 000000F6 00000004		four    DWORD   4
 000000FA 00000000		lim     DWORD   ?
 00000000			.CODE
 00000000			_MainProc PROC

				;***  Print the original, unsorted list

				        ; ECX holds the address of the string being built
 00000000  8D 0D 0000002C R	        lea	   ecx, string

				        ; EBX will hold the address of the current item in the array
 00000006  8D 1D 00000000 R	        lea    ebx, array

				        ; Look for the 0 at the end of the list
 0000000C  8B 03		out1:   mov    eax, [ebx]
 0000000E  3C 00		        cmp    al, 0
 00000010  74 2F		        je     outputstring

				        ; Convert the number to a series of characters
				        dtoa   numstr, eax

				        ; Copy the characters to the string being build
 0000002A  8D 15 00000090 R	        lea    edx, numstr
 00000030  8B 02		while1: mov     eax, [edx]
 00000032  3C 00		        cmp     al, 0
 00000034  75 05		        jne     movechar
 00000036  83 C3 04		        add     ebx,4
 00000039  EB D1		        jmp     out1
 0000003B			movechar:
 0000003B  89 01		        mov     [ecx], eax      ; Move the character
 0000003D  42			        inc     edx             ; Increment counters
 0000003E  41			        inc     ecx
 0000003F  EB EF		        jmp     while1

				        ; Now output the string.
 00000041			outputstring:
				        output  prompt1, string


				;*** Now launch into the Bubble Sort

				;***************  ADD BUBBLE SORT CODE HERE ************************

 0000005A  8D 1D 00000000 R	        lea     ebx, array          ; Grab first value of array
 00000060  8B 0B		        mov     ecx, [ebx]          ; Load its value into eax
				        ;jecxz   display2            ; if itz zero just stop 
				       
 00000062  89 1D 000000BE R	        mov     i, ebx              ; i becomes index
 00000068  89 1D 000000C2 R	        mov     j, ebx              ; j becomes index as well


 0000006E  C7 05 000000BA R	        mov     n, LENGTHOF array
	   0000000A
 00000078  B9 00000000		        mov     ecx, 0              ; reset ecx to 0 so we can coutn with it
 0000007D  83 2D 000000BA R	        sub     n, 1                ; make it n -1
	   01
 00000084  83 3D 000000BA R	        cmp     n, 0                ; check if length of array is 0 
	   00
				        ;je      display2             ; if the length is 0 the array is sorted

 0000008B  EB 00		        jmp     forOne              ; jmp to outer for loop

 0000008D			forOne:
 0000008D  3B 0D 000000BA R	      cmp   ecx, n  ; compare ecx and n (-1) 
 00000093  74 66		      je    display2 ; if equal done

				      ; print value of arr
 00000095  8B 1D 000000BE R	      mov   ebx, i              ; ECX = counter for for loop 1 
 0000009B  8B 33		      mov   esi, [ebx]          ; ESI HOLDS [i] OF ARRAY 

 0000009D  8B 1D 000000BA R	      mov   ebx, n              ; Use ebx as temp register to find new limit for the inner for loop
 000000A3  2B D9		      sub   ebx, ecx
 000000A5  89 1D 000000FA R	      mov   lim, ebx

 000000AB  8D 1D 00000000 R	      lea   ebx, array          ; j is now the start of the array
 000000B1  89 1D 000000C2 R	      mov   j, ebx
 000000B7  BB 00000000		      mov   ebx, 0 

 000000BC  EB 0E		      jmp forTwo
				 
 000000BE  B8 00000004		      mov   eax, 4              ; INCREMENT i 
 000000C3  01 05 000000BE R	      add   i, eax 

 000000C9  41			      inc    ecx
 000000CA  EB C1		      jmp    forOne
				      ; else
				    
				      
 000000CC			forTwo:
 000000CC  3B 1D 000000FA R	      cmp   ebx, lim            ; EBX = counter for for loop 2
 000000D2  74 B9		      je    forOne

 000000D4  A1 000000C2 R	      mov   eax, j              ; current location in mem
 000000D9  8B 38		      mov   edi, [eax]
 000000DB  3B 78 04		      cmp   edi, [eax+4]   ; if array[j] > array[j+1] jmp swap 

 000000DE  83 05 000000C2 R	      add   j, 4                ; inc j (+4)
	   04
 000000E5  43			      inc   ebx      
 000000E6  43			      inc ebx               ; inc ebx   

 000000E7  7F 02		      jg    swapLbl             ; jg swap
				      ; else
 000000E9  EB E1		      jmp forTwo                ; restart loop



 000000EB			swapLbl:
 000000EB  89 35 00000028 R	        mov temp, esi
 000000F1  8B F7		        mov esi, edi
 000000F3  8B 3D 00000028 R	        mov edi, temp
 000000F9  EB D1		        jmp forTwo


				;***  Print the new sorted list

 000000FB			display2:
				        ; ECX holds the address of the string being built
 000000FB  8D 0D 0000002C R	        lea	   ecx, string

				        ; EBX will hold the address of the current item in the array
 00000101  8D 1D 00000000 R	        lea    ebx, array

				        ; Look for the 0 at the end of the list
 00000107  8B 03		out2:   mov    eax, [ebx]
 00000109  3C 00		        cmp    al, 0
 0000010B  74 2F		        je     outputstring2

				        ; Convert the number to a series of characters
				        dtoa   numstr, eax

				        ; Copy the characters to the string being build
 00000125  8D 15 00000090 R	        lea    edx, numstr
 0000012B  8B 02		while2: mov     eax, [edx]
 0000012D  3C 00        cmp     al, 0
 0000012F  75 05		        jne     movechar2
 00000131  83 C3 04		        add     ebx,4
 00000134  EB D1		        jmp     out2
 00000136			movechar2:
 00000136  89 01		        mov     [ecx], eax      ; Move the character
 00000138  42			        inc     edx             ; Increment counters
 00000139  41			        inc     ecx
 0000013A  EB EF		        jmp     while2

				        ; Now output the string.
 0000013C			outputstring2:
				        output  prompt1, string

 00000155  B8 00000000		        mov     eax, 0  ; exit with return code 0
 0000015A  C3			        ret
 0000015B			_MainProc ENDP
				END                             ; end of source code
Microsoft (R) Macro Assembler Version 14.35.32216.1	    04/12/23 14:22:56
example.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

atod . . . . . . . . . . . . . .	Proc
atow . . . . . . . . . . . . . .	Proc
dtoa . . . . . . . . . . . . . .	Proc
input  . . . . . . . . . . . . .	Proc
output . . . . . . . . . . . . .	Proc
wtoa . . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000000FE Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 0000015B Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

_MainProc  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000015B Public
  out1 . . . . . . . . . . . . .	L Near	 0000000C _TEXT	
  while1 . . . . . . . . . . . .	L Near	 00000030 _TEXT	
  movechar . . . . . . . . . . .	L Near	 0000003B _TEXT	
  outputstring . . . . . . . . .	L Near	 00000041 _TEXT	
  forOne . . . . . . . . . . . .	L Near	 0000008D _TEXT	
  forTwo . . . . . . . . . . . .	L Near	 000000CC _TEXT	
  swapLbl  . . . . . . . . . . .	L Near	 000000EB _TEXT	
  display2 . . . . . . . . . . .	L Near	 000000FB _TEXT	
  out2 . . . . . . . . . . . . .	L Near	 00000107 _TEXT	
  while2 . . . . . . . . . . . .	L Near	 0000012B _TEXT	
  movechar2  . . . . . . . . . .	L Near	 00000136 _TEXT	
  outputstring2  . . . . . . . .	L Near	 0000013C _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
_getInput  . . . . . . . . . . .	L Near	 00000000 FLAT	External
_showOutput  . . . . . . . . . .	L Near	 00000000 FLAT	External
array  . . . . . . . . . . . . .	DWord	 00000000 _DATA	
atodproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
atowproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
dtoaproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
four . . . . . . . . . . . . . .	DWord	 000000F6 _DATA	
inlimit  . . . . . . . . . . . .	DWord	 000000B6 _DATA	
i  . . . . . . . . . . . . . . .	DWord	 000000BE _DATA	
j  . . . . . . . . . . . . . . .	DWord	 000000C2 _DATA	
lim  . . . . . . . . . . . . . .	DWord	 000000FA _DATA	
numstr . . . . . . . . . . . . .	Byte	 00000090 _DATA	
n  . . . . . . . . . . . . . . .	DWord	 000000BA _DATA	
prompt1  . . . . . . . . . . . .	Byte	 0000009C _DATA	
prompt2  . . . . . . . . . . . .	Byte	 000000AA _DATA	
string . . . . . . . . . . . . .	Byte	 0000002C _DATA	
temp . . . . . . . . . . . . . .	DWord	 00000028 _DATA	
testStr  . . . . . . . . . . . .	DWord	 000000CA _DATA	
tmp  . . . . . . . . . . . . . .	DWord	 000000C6 _DATA	
wtoaproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External

	   0 Warnings
	   0 Errors
