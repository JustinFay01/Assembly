Microsoft (R) Macro Assembler Version 14.35.32216.1	    04/12/23 12:06:58
example.asm						     Page 1 - 1


				;  Week 14 day 1 Exercise: Bubble Sort!
				;
				;  Mike Jipping
				;  April 2019


				.586
				.MODEL FLAT

				INCLUDE io.h            ; header file for input/output
			      C ; IO.H -- header file for I/O macros (listing suppressed)
			      C .NOLIST      ; turn off listing
			      C .LIST        ; begin listing
			      C 

				.STACK 4096

 00000000			.DATA
 00000000 0000000A		array   DWORD   10, 30, 20, 100, 90, 30, 9, 40, 35, 0
	   0000001E
	   00000014
	   00000064
	   0000005A
	   0000001E
	   00000009
	   00000028
	   00000023
	   00000000
 00000028 00000000		temp    DWORD   ?
 0000002C  00000064 [		string  BYTE    100 DUP (?)
	    00
	   ]
 00000090  0000000B [		numstr  BYTE    11 DUP (?), 0
	    00
	   ] 00
 0000009C 55 6E 73 6F 72	prompt1 BYTE    "Unsorted List", 0
	   74 65 64 20 4C
	   69 73 74 00
 000000AA 53 6F 72 74 65	prompt2 BYTE    "Sorted List", 0
	   64 20 4C 69 73
	   74 00
 000000B6 00000000		inlimit DWORD   ?

 000000BA 00000000		n       DWORD   ?
 000000BE 00000000		i       DWORD   0
 000000C2 00000000		j       DWORD   0
 000000C6  0000000A [		testStr DWORD   10 DUP (?), 0
	    00000000
	   ] 00000000
 00000000			.CODE
 00000000			_MainProc PROC

				;***  Print the original, unsorted list

				        ; ECX holds the address of the string being built
 00000000  8D 0D 0000002C R	        lea	   ecx, string

				        ; EBX will hold the address of the current item in the array
 00000006  8D 1D 00000000 R	        lea    ebx, array

				        ; Look for the 0 at the end of the list
 0000000C  8B 03		out1:   mov    eax, [ebx]
 0000000E  3C 00		        cmp    al, 0
 00000010  74 2F		        je     outputstring

				        ; Convert the number to a series of characters
				        dtoa   numstr, eax

				        ; Copy the characters to the string being build
 0000002A  8D 15 00000090 R	        lea    edx, numstr
 00000030  8B 02		while1: mov     eax, [edx]
 00000032  3C 00		        cmp     al, 0
 00000034  75 05		        jne     movechar
 00000036  83 C3 04		        add     ebx,4
 00000039  EB D1		        jmp     out1
 0000003B			movechar:
 0000003B  89 01		        mov     [ecx], eax      ; Move the character
 0000003D  42			        inc     edx             ; Increment counters
 0000003E  41			        inc     ecx
 0000003F  EB EF		        jmp     while1

				        ; Now output the string.
 00000041			outputstring:
				        output  prompt1, string


				;*** Now launch into the Bubble Sort

				;***************  ADD BUBBLE SORT CODE HERE ************************

 0000005A  8D 1D 00000000 R	        lea     ebx, array          ; Grab first value of array
 00000060  8B 0B		        mov     ecx, [ebx]          ; Load its value into eax
 00000062  E3 27		        jecxz   doneLbl             ; if itz zero just stop 
				       
 00000064  89 1D 000000BE R	        mov     i, ebx              ; i becomes index


 0000006A  C7 05 000000BA R	        mov     n, LENGTHOF array
	   0000000A
 00000074  B9 00000000		        mov     ecx, 0              ; reset ecx to 0 so we can coutn with it
 00000079  83 2D 000000BA R	        sub     n, 1                ; make it n -1
	   01
 00000080  83 3D 000000BA R	        cmp     n, 0                ; check if length of array is 0 
	   00
 00000087  74 02		        je      doneLbl             ; if the length is 0 the array is sorted

 00000089  EB 01		        jmp     forOne              ; jmp to outer for loop

 0000008B			doneLbl:
 0000008B  C3			    ret

 0000008C			forOne:
 0000008C  3B 0D 000000BA R	      cmp   ecx, n  ; compare ecx and n (-1) 
 00000092  74 F7		      je    doneLbl ; if equal done

				      ; print value of arr
 00000094  8B 1D 000000BE R	      mov   ebx, i 
 0000009A  8B 03		      mov   eax, [ebx]  
				     
 0000009C  BE 00000004		      mov   esi, 4
 000000A1  01 35 000000BE R	      add   i, esi 

				      
				      
				      dtoa      testStr, eax
				      output    testStr, testStr

				      
 000000D8  41			      inc    ecx
 000000D9  EB B1		      jmp    forOne
				      ; else
				      
				    
 000000DB  C3			      ret
 000000DC			forTwo:

 000000DC			SwapLbl:



				;***  Print the new sorted list

 000000DC			display2:
				        ; ECX holds the address of the string being built
 000000DC  8D 0D 0000002C R	        lea	   ecx, string

				        ; EBX will hold the address of the current item in the array
 000000E2  8D 1D 00000000 R	        lea    ebx, array

				        ; Look for the 0 at the end of the list
 000000E8  8B 03		out2:   mov    eax, [ebx]
 000000EA  3C 00		        cmp    al, 0
 000000EC  74 2F		        je     outputstring2

				        ; Convert the number to a series of characters
				        dtoa   numstr, eax

				        ; Copy the characters to the string being build
 00000106  8D 15 00000090 R	        lea    edx, numstr
 0000010C  8B 02		while2: mov     eax, [edx]
 0000010E  3C 00		        cmp     al, 0
 00000110  75 05		        jne     movechar2
 00000112  83 C3 04		        add     ebx,4
 00000115  EB D1		        jmp     out2
 00000117			movechar2:
 00000117  89 01		        mov     [ecx], eax      ; Move the character
 00000119  42			        inc     edx             ; Increment counters
 0000011A  41			        inc     ecx
 0000011B  EB EF		        jmp     while2

				        ; Now output the string.
 0000011D			outputstring2:
				        output  prompt1, string

 00000136  B8 00000000		        mov     eax, 0  ; exit with return code 0
 0000013B  C3			        ret
 0000013C			_MainProc ENDP
				END                             ; end of source code
Microsoft (R) Macro Assembler Version 14.35.32216.1	    04/12/23 12:06:58
example.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

atod . . . . . . . . . . . . . .	Proc
atow . . . . . . . . . . . . . .	Proc
dtoa . . . . . . . . . . . . . .	Proc
input  . . . . . . . . . . . . .	Proc
output . . . . . . . . . . . . .	Proc
wtoa . . . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000000F2 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 0000013C Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

_MainProc  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000013C Public
  out1 . . . . . . . . . . . . .	L Near	 0000000C _TEXT	
  while1 . . . . . . . . . . . .	L Near	 00000030 _TEXT	
  movechar . . . . . . . . . . .	L Near	 0000003B _TEXT	
  outputstring . . . . . . . . .	L Near	 00000041 _TEXT	
  doneLbl  . . . . . . . . . . .	L Near	 0000008B _TEXT	
  forOne . . . . . . . . . . . .	L Near	 0000008C _TEXT	
  forTwo . . . . . . . . . . . .	L Near	 000000DC _TEXT	
  SwapLbl  . . . . . . . . . . .	L Near	 000000DC _TEXT	
  display2 . . . . . . . . . . .	L Near	 000000DC _TEXT	
  out2 . . . . . . . . . . . . .	L Near	 000000E8 _TEXT	
  while2 . . . . . . . . . . . .	L Near	 0000010C _TEXT	
  movechar2  . . . . . . . . . .	L Near	 00000117 _TEXT	
  outputstring2  . . . . . . . .	L Near	 0000011D _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
_getInput  . . . . . . . . . . .	L Near	 00000000 FLAT	External
_showOutput  . . . . . . . . . .	L Near	 00000000 FLAT	External
array  . . . . . . . . . . . . .	DWord	 00000000 _DATA	
atodproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
atowproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
dtoaproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External
inlimit  . . . . . . . . . . . .	DWord	 000000B6 _DATA	
i  . . . . . . . . . . . . . . .	DWord	 000000BE _DATA	
j  . . . . . . . . . . . . . . .	DWord	 000000C2 _DATA	
numstr . . . . . . . . . . . . .	Byte	 00000090 _DATA	
n  . . . . . . . . . . . . . . .	DWord	 000000BA _DATA	
prompt1  . . . . . . . . . . . .	Byte	 0000009C _DATA	
prompt2  . . . . . . . . . . . .	Byte	 000000AA _DATA	
string . . . . . . . . . . . . .	Byte	 0000002C _DATA	
temp . . . . . . . . . . . . . .	DWord	 00000028 _DATA	
testStr  . . . . . . . . . . . .	DWord	 000000C6 _DATA	
wtoaproc . . . . . . . . . . . .	L Near	 00000000 FLAT	External

	   0 Warnings
	   0 Errors
